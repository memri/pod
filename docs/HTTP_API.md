# About
This documentation is part of [Pod](../README.md).

HTTP API is the interface that Pod provides to store and access user data.
This document explains the data types that Pod can store,
and current API provided for that.


# API Authentication & Credentials
Accessing your Pod requires authentication.
This is typically the `owner_key` and `auth` keys in the request, see below.

## Owner key
The `owner_key` tells the Pod *who* you claim to be.
It is the full client's public [ED25519](https://ed25519.cr.yp.to/) key
(see also [wikipedia](https://en.wikipedia.org/wiki/Curve25519)).
It should be encoded as 64-character hex string.  
Pods configured with "ANY" as their owner will accept requests from any `owner_key`.
For debugging, you can fake `owner_key` by providing any 64 hex characters, e.g. all zeroes.  
Note that for now, we don't really use any cryptography for the `owner_key`,
but in the future we probably will.

## Auth key
The `auth` value is used by Pod to *validate* that this is you,
and to temporarily *decrypt* parts of your data required to serve your request.
This key is immediately lost by Pod when the HTTP request is closed.

There are two types of `auth` keys,

* a plugin key (that plugins get from Pod and will use to authorize in Pod),
* and a client key (that Memri clients will use, e.g. a phone or desktop app).

#### Auth key of "plugin" type
Note: plugin keys are NOT implemented yet, use "client" keys for now (to be changed 2021-04 - 2021-05).

As a plugin, you don't have access to a database_key,
so you can only use plugin authorization.
In text below `$POD_AUTH` is the key you [received from Pod](./Plugins.md).

Your auth key should be of the form:
```json5
{
  "type": "PluginAuth",
  "blob": "******"  /* POD_AUTH_BLOB string that you received from Pod */
}
```

For debugging, if you run your own Pod locally,
you can use client auth (below) by just making up a fake user and a fake database key.

#### Auth key of "client" type
If you're a memri client, you keep the secret locally,
in an encrypted/protected form.

Your auth key should be of the form:
```json5
{
  "type": "ClientAuth",
  "database_key": "*********"
}
```
The `databaseKey` is a 64-character hex string to be used for validation and encryption.
You can use any [*cryptographically secure* PRNG](https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator)
to generate the key.
It should be generated once and stored securely, e.g. in a hardware-backed keystore, or
[secure enclave](https://support.apple.com/guide/security/secure-enclave-sec59b0b31ff/web), etc.
The key will internally be used with [sqlcipher](https://github.com/sqlcipher/sqlcipher).

For debugging (and for debugging only!) you can use any 64 hex characters, e.g. all zeroes.


# Schema API
Schema defines what types can be stored in Pod. You can read more
about the Schema itself [here](./Schema.md).

In order to make changes to the schema, insert items of a specific structure in the Pod.
The following properties are expected:
```json5
{
  "type": "ItemPropertySchema", /* exactly this, and nothing else */
  "itemType": "YourType", /* e.g. "Person" */
  "propertyName": "yourProperty", /* e.g. "age" */
  "valueType": "Integer", /* one of valid Schema types, see Schema docs*/
}
```

Note that you cannot both change the Schema and refer to the new Schema
in one `bulk` request, so if you want changes to the Schema to happen first,
split updates to the Schema into a separate request.
(This constraint might be lifted in the future.)


# Items API

### GET /version
Get version of the Pod: the git commit and cargo version that it was built from.


### POST /v3/$owner_key/get_item
```json
{
  "auth": $auth_json,
  "payload": $id
}
```
Get a single item by its `id`.

Returns an empty array if an item is not found,
or an array with 1 item if item exists.


### POST /v3/$owner_key/create_item
```json
{
  "auth": $auth_json,
  "payload": { "type": "...", ... }
}
```
Create a single item.

* `id` if set, will be taken as new item's `id`;
    otherwise, a new id will be generated by Pod
* `type` sets the type of the item, cannot ever be changed
* `dateCreated` if not present, will be set by the backend
* `dateModified` if not present, will be set by the backend
* `dateServerModified` will be created by the backend
* any other properties will be added to the item's properties

Returns an error if such `id` already exist in the DB.
Returns an error if the new item doesn't conform to the Schema.
Returns `id` of the created item if the operation is successful. 


### POST /v3/$owner_key/update_item
```json
{
  "auth": $auth_json,
  "payload": { "id": $id, ... }
}
```
Update a single item.

* `id` from the input json will be taken as the item's `id`
* `type` from the input json will be ignored
* `dateCreated` from the input json will be ignored
* `dateModified` if not present, will be updated by the backend
* `dateServerModified` will be created by the backend
* properties with a value of `null` will be erased from the item
* any other properties will be updated

Returns an empty object if the operation is successful.


### POST /v3/$owner_key/delete_item
```json
{
  "auth": $auth_json,
  "payload": $id
}
```
Mark an item as deleted:
* Set `deleted` flag to `true`
* Update `dateModified` (server's time is taken)
* Update `dateServerModified`


### POST /v3/$owner_key/search
```json
{
  "auth": $auth_json,
  "payload": {
    "type": "Label",
    "dateServerModified>=": 1234567890,
    "dateServerModified<": 1234567890,
    "deleted": false
  }
}
```
Search items by their properties.

The endpoint will return an array of all items with exactly the same properties.

As a first step of the 2021-03 Pod rewrite, only the above properties are supported.
In the future, any will be available.


### POST /v3/$owner_key/bulk
```json
{
  "auth": $auth_json,
  "payload": {
    "createItems": [
      { "id": "something-12345", "type": "Person", ... }, ...
    ],
    "updateItems": [
      { "id": "something-67899", ... }, ...
    ],
    "deleteItems": [ $id, $id, $id, ...],
  }
}
```
Perform a bulk of operations in one request.
The endpoint is "atomic", meaning that either all the operations succeed,
or the database won't be changed at all.

Returns an empty object if the operation is successful.


<!--
# Services API
Services help getting data into your Pod and enriching it.
Services can only be ever run / authorized to run by the user.
Typical examples of services are services that import emails/messages into Pod.

### POST /v3/$owner_key/run_importer
```json
{
  "auth": $auth_json,
  "payload": {
    "id": $id,
    "servicePayload": {
      "databaseKey": "2DD29CA851E7B56E4697B0E1F08507293D761A05CE4D1B628663F411A8086D99",
      "ownerKey": $owner_key
    }
  }
}
```
Run an importer on an item with the given id.
See [Integrators](./Integrators.md).


# File API


### POST /v3/$owner_key/upload_file/$database_key/$sha256hashOfTheFile
```text
RAW-FILE-BINARY
```
Upload a file into Pod and verify it's `sha256`.
`owner_key`, database key and sha256 are all hex-encoded.

If a file with a given `sha256` has already being uploaded, the request will fail.
If the provided `sha256` doesn't match the hash of the contents, the request will fail.
If no item with this `sha256` exists in the database, Pod wouldn't be able to store
cryptographic information about the file, and the request will also fail.

If `sha256` matches, the file has not yet been uploaded to Pod and if an item
with such `sha256` already exists in DB, Pod will accept the file and store it.
The properties `nonce` and `key` will be updated for this item.


### POST /v3/$owner_key/get_file
```json
{
  "auth": $auth_json,
  "payload": {
    "sha256": $sha256
  }
}
```
Get a file by its sha256 hash.
If the file does not yet exist in Pod, a 404 NOT FOUND error will be returned.
-->
