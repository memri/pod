use lazy_static::lazy_static;
use std::net::IpAddr;
use std::net::SocketAddr;
use std::path::PathBuf;
use structopt::clap::AppSettings;
use structopt::StructOpt;

#[derive(StructOpt, Debug)]
#[structopt(
    name = "Pod, the open-source backend for Memri project.",
    setting = AppSettings::DeriveDisplayOrder,
    setting = AppSettings::UnifiedHelpMessage,
    version = VERSION.as_ref(),
)]
pub struct CLIOptions {
    /// Port to listen to.
    #[structopt(short, long, default_value = "3030")]
    port: i16,

    /// File to read https public certificate from.
    #[structopt(
        short = "c",
        long,
        default_value = "./data/certs/pod.crt",
        name = "CERTIFICATE_FILE"
    )]
    https_pub_crt: String,

    /// File to read https private key from.
    #[structopt(
        short = "k",
        long,
        default_value = "./data/certs/pod.key",
        name = "KEY_FILE"
    )]
    https_priv_key: String,

    /// Set the callback address for services launched from within Pod.
    /// This should be the Pod-s address as seen by external services.
    /// During development, it defaults to "https://pod_pod_1:3030" if Pod is inside docker,
    /// or "https://localhost:3030" on Linux,
    /// or "https://host.docker.internal:3030" on other operating systems.
    #[structopt(short = "s", long, name = "ADDRESS")]
    services_callback_address: Option<SocketAddr>,

    /// Do not use https when starting the server, instead run on http://127.0.0.1.
    /// Running on loopback interface (127.0.0.1) means that only apps
    /// from within the same computer will be able to access Pod.
    /// This option might be used during development as an alternative to self-signed certificates.
    #[structopt(short = "t", long)]
    non_tls: bool,

    /// Unsafe version of --non-tls. Do not use https when starting the server,
    /// instead run on http on the provided network interface.
    /// WARNING: This is heavily discouraged as an intermediary
    /// (even your router on a local network)
    /// could spoof the traffic sent to the server and do a MiTM attack.
    /// Please consider running Pod on a non-public network (--non-tls),
    /// or use Pod with https encryption.
    #[structopt(short, long)]
    insecure_non_tls: Option<IpAddr>,

    /// Comma-separated list of Pod owners (hex-encoded hashes of public keys).
    /// Only those owners are allowed to call Pod endpoints.
    /// Each Pod owner has its own database and files directory,
    /// the owners do not intersect data-wise.
    ///
    /// A magic value of "ANY" will allow any owner to connect to the Pod.
    ///
    /// Can be specified multiple times.
    #[structopt(short = "o", long, required = true, multiple = true)]
    owner: Vec<String>,

    /// Validate a schema file, and exit.
    /// This allows testing whether a given schema is suitable for use in Pod,
    /// see README.md#schema for details.
    /// Note that running project tests or starting the Pod will also automatically validate
    /// the schema in `res/autogenerated_database_schema.json`.
    #[structopt(short = "v", long, name = "SCHEMA_FILE", parse(from_os_str))]
    validate_schema: Option<PathBuf>,
}

lazy_static! {
    // Don't change to `&'static str` for now, it's a bit hard to get lifetimes straight with Clap.
    pub static ref VERSION: String = {
        // Ideas for future:
        //   * print "which branch" does the commit belong to
        //   * print "dirty" indicator (whether there are local uncommitted changes)
        env!("GIT_DESCRIBE").to_string()
    };
}
