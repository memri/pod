use log::info;
use r2d2::{Pool, PooledConnection};
use r2d2_sqlite::SqliteConnectionManager;
use rusqlite::NO_PARAMS;
use serde::Deserialize;
use serde::Serialize;
use std::collections::HashMap;
use std::collections::HashSet;
use std::hash::Hash;

/// Constraints:
///
/// * All column definitions of the same case-insensitive name MUST have the same type and indexing
///
/// * All column names MUST consist of `a-zA-Z_` characters only,
/// and start with `a-zA-Z`
///
/// * All type names MUST consist of `a-zA-Z_` characters only,
/// and start with `a-zA-Z` (same as column names)
#[derive(Serialize, Deserialize)]
struct DatabaseSchema {
    types: Vec<DatabaseType>,
}

#[derive(Serialize, Deserialize)]
struct DatabaseType {
    name: String,
    columns: Vec<DatabaseColumn>,
}

#[derive(Serialize, Deserialize)]
struct DatabaseColumn {
    name: String,
    indexed: bool,
    dbtype: DatabaseColumnType,
}

#[derive(Serialize, Deserialize, Debug, Copy, Clone, PartialEq)]
enum DatabaseColumnType {
    /// UTF-8 string
    Text,
    /// Signed 8-byte integer
    Integer,
    // 8-byte float
    Real,
}

pub const AUTOGENERATED_SCHEMA: &[u8] = include_bytes!("../res/autogenerated_database_schema.json");

pub fn init(sqlite: &Pool<SqliteConnectionManager>) {
    info!("Initializing database schema (mandatory tables)");
    let conn = sqlite
        .get()
        .expect("Failed to aquire SQLite connection during db initialization");
    conn.execute_batch(ITEMS_TABLE_DDL)
        .unwrap_or_else(|err| panic!("Failed to create items table, {}", err));
    conn.execute_batch(RELATIONS_TALBLE_DDL)
        .unwrap_or_else(|err| panic!("Failed to create relations table, {}", err));
    conn.execute_batch(ITEMS_INDEX_DDL)
        .unwrap_or_else(|err| panic!("Failed to create items indexes, {}", err));
    conn.execute_batch(RELATION_INDEXES_DDL)
        .unwrap_or_else(|err| panic!("Failed to create relations indexes, {}", err));

    info!("Initializing database schema (additional columns)");
    let parsed_schema: DatabaseSchema = serde_json::from_slice(AUTOGENERATED_SCHEMA)
        .expect("Failed to parse autogenerated_database_schema to JSON");
    let (column_indexes, declared_columns) = get_column_info(parsed_schema, &conn);
    let sql = generate_sql(column_indexes, declared_columns);
    if !sql.is_empty() {
        info!("Updating database schema with:\n{}", sql);
    }

    conn.execute_batch(&sql)
        .unwrap_or_else(|err| panic!("Failed to execute SQL\n{}\n{}", sql, err));
}

fn get_column_info(
    parsed_schema: DatabaseSchema,
    conn: &PooledConnection<SqliteConnectionManager>,
) -> (HashMap<String, bool>, HashMap<String, DatabaseColumnType>) {
    let mut column_indexes = HashMap::new();
    let mut declared_columns = HashMap::new();

    let all_items_columns: HashSet<String> = get_all_columns_gragma("items", conn)
        .expect("Failed to get items column information using PRAGMA");

    let columns = parsed_schema.types.iter().flat_map(|t| &t.columns);
    let columns_grouped = group_by(columns, |c| c.name.to_lowercase());
    for (column_name, column_group) in columns_grouped {
        if MANDATORY_ITEMS_FIELDS.contains(&column_name.as_str()) {
            continue;
        }

        let needs_index = column_group.iter().any(|c| c.indexed);
        column_indexes.insert(column_name.to_string(), needs_index);

        if all_items_columns.contains(&column_name) {
            // SQLite cannot add columns "IF NOT EXIST", so we need to manually skip
            continue;
        }

        let db_type = column_group
            .first()
            .expect("All groups of `group_by` have at least 1 element");
        let db_type = db_type.dbtype;

        assert!(
            column_group.iter().all(|c| c.dbtype == db_type),
            "Column {} has inconsistent database type",
            column_name
        );
        declared_columns.insert(column_name, db_type);
    }
    (column_indexes, declared_columns)
}

// Solution taken from here:
// https://stackoverflow.com/questions/18920136/check-if-a-column-exists-in-sqlite
//
// Note that the approach of querying `pragma_table_info`
// does not work on older sqlcipher versions (ubuntu 20.04 still uses sqlcipher 3.4).
fn get_all_columns_gragma(
    table: &str,
    conn: &PooledConnection<SqliteConnectionManager>,
) -> rusqlite::Result<HashSet<String>> {
    let sql = format!("PRAGMA table_info('{}');", table);
    let mut stmt = conn.prepare_cached(&sql)?;
    let mut rows = stmt.query(NO_PARAMS)?;
    let mut result = HashSet::new();
    while let Some(row) = rows.next()? {
        let column_name: String = row
            .get(1)
            .expect("Column 1 of PRAGMA table_info code is not a table column name");
        result.insert(column_name);
    }
    Ok(result)
}

fn generate_sql(
    column_indexes: HashMap<String, bool>,
    declared_columns: HashMap<String, DatabaseColumnType>,
) -> String {
    let mut result = String::new();

    for (column, db_type) in declared_columns {
        let creation = format!("ALTER TABLE items ADD {} {:?};", column, db_type);
        result.push_str(&creation);
        result.push_str("\n");
    }

    for (column, is_indexed) in column_indexes {
        let index = if is_indexed {
            format!(
                "CREATE INDEX IF NOT EXISTS idx_items_{} ON items({}) WHERE {} IS NOT NULL;",
                column, column, column
            )
        } else {
            format!("DROP INDEX IF EXISTS idx_items_{};", column)
        };
        result.push_str(&index);
        result.push_str("\n");
    }

    result
}

pub fn group_by<T, K, F>(collection: T, grouping_func: F) -> HashMap<K, Vec<T::Item>>
where
    T: IntoIterator,
    F: Fn(&T::Item) -> K,
    K: Eq + Hash,
{
    let mut map = HashMap::new();
    for item in collection {
        let group = grouping_func(&item);
        map.entry(group).or_insert_with(|| vec![]).push(item);
    }
    map
}

const MANDATORY_ITEMS_FIELDS: &[&str] = &[
    "uid",
    "type",
    "dateCreated",
    "dateModified",
    "dateAccessed",
    "deleted",
    "version",
];

const ITEMS_TABLE_DDL: &str = "CREATE TABLE IF NOT EXISTS items (
    uid INTEGER NOT NULL PRIMARY KEY,
    type TEXT NOT NULL,
    dateCreated REAL NOT NULL,
    dateModified REAL NOT NULL,
    dateAccessed REAL,
    deleted INTEGER,
    version INTEGER NOT NULL
);";

const ITEMS_INDEX_DDL: &str = "
    CREATE INDEX IF NOT EXISTS idx_items_dateCreated ON items(dateCreated);
    CREATE INDEX IF NOT EXISTS idx_items_dateModified ON items(dateModified);
    CREATE INDEX IF NOT EXISTS idx_items_dateAccessed ON items(dateAccessed) WHERE dateAccessed IS NOT NULL;
    CREATE INDEX IF NOT EXISTS idx_items_type_dateModified ON items(type, dateModified);
";

const RELATIONS_TALBLE_DDL: &str = "CREATE TABLE IF NOT EXISTS relations (
    source INTEGER NOT NULL,
    target INTEGER NOT NULL,
    type TEXT NOT NULL,
    dateCreated REAL NOT NULL,
    dateModified REAL NOT NULL,
    dateAccessed REAL,
    FOREIGN KEY (source) REFERENCES items(uid),
    FOREIGN KEY (target) REFERENCES items(uid),
    UNIQUE(source, target, type)
);";

const RELATION_INDEXES_DDL: &str = "
    CREATE INDEX IF NOT EXISTS idx_relations_source_type ON relations(source, type);
    CREATE INDEX IF NOT EXISTS idx_relations_target_type ON relations(target, type);
    CREATE INDEX IF NOT EXISTS idx_relations_dateModified ON relations(dateModified);
    CREATE INDEX IF NOT EXISTS idx_relations_dateAccessed ON relations(dateAccessed) WHERE dateAccessed IS NOT NULL;
";
