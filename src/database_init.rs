use lazy_static::lazy_static;
use log::info;
use r2d2::Pool;
use r2d2::PooledConnection;
use r2d2_sqlite::SqliteConnectionManager;
use rusqlite::NO_PARAMS;
use serde::Deserialize;
use serde::Serialize;
use std::collections::HashMap;
use std::collections::HashSet;
use std::hash::Hash;

/// Constraints:
///
/// * All column definitions of the same case-insensitive name MUST have the same type and indexing
///
/// * All column names MUST consist of `a-zA-Z_` characters only,
/// and start with `a-zA-Z`
///
/// * All type names MUST consist of `a-zA-Z_` characters only,
/// and start with `a-zA-Z` (same as column names)
#[derive(Serialize, Deserialize)]
struct DatabaseSchema {
    types: Vec<DatabaseType>,
}

#[derive(Serialize, Deserialize)]
struct DatabaseType {
    name: String,
    columns: Vec<DatabaseColumn>,
}

#[derive(Serialize, Deserialize)]
struct DatabaseColumn {
    name: String,
    indexed: bool,
    dbtype: DatabaseColumnType,
}

#[derive(Serialize, Deserialize, Debug, Copy, Clone, PartialEq)]
enum DatabaseColumnType {
    /// UTF-8 string
    Text,
    /// Signed 8-byte integer
    Integer,
    // 8-byte float
    Real,
    // Boolean
    Bool,
}

lazy_static! {
    pub static ref BOOL_COLUMNS: HashSet<String> = {
        let parsed_schema: DatabaseSchema = serde_json::from_slice(AUTOGENERATED_SCHEMA)
            .expect("Failed to parse autogenerated_database_schema to JSON");
        let columns = parsed_schema.types.iter().flat_map(|t| &t.columns);
        let mut result = HashSet::new();
        for column in columns {
            if column.dbtype == DatabaseColumnType::Bool {
                result.insert(column.name.to_string());
            }
        }
        result.insert("deleted".to_string());
        result
    };
}

pub const AUTOGENERATED_SCHEMA: &[u8] = include_bytes!("../res/autogenerated_database_schema.json");

pub fn init(sqlite: &Pool<SqliteConnectionManager>) {
    info!("Initializing database schema (mandatory tables)");
    let conn = sqlite
        .get()
        .expect("Failed to aquire SQLite connection during db initialization");

    info!("Initializing database schema (additional columns)");
    let parsed_schema: DatabaseSchema = serde_json::from_slice(AUTOGENERATED_SCHEMA)
        .expect("Failed to parse autogenerated_database_schema to JSON");
    let (column_indexes, declared_columns) = get_column_info(parsed_schema, &conn);
    let sql = generate_sql(column_indexes, declared_columns);
    if !sql.is_empty() {
        info!("Updating database schema with:\n{}", sql);
    }

    conn.execute_batch(&sql)
        .unwrap_or_else(|err| panic!("Failed to execute SQL\n{}\n{}", sql, err));
}

fn get_column_info(
    parsed_schema: DatabaseSchema,
    conn: &PooledConnection<SqliteConnectionManager>,
) -> (HashMap<String, bool>, HashMap<String, DatabaseColumnType>) {
    let mut column_indexes = HashMap::new();
    let mut declared_columns = HashMap::new();

    let all_items_columns: HashSet<String> = get_all_columns_gragma("items", conn)
        .expect("Failed to get items column information using PRAGMA");

    let columns = parsed_schema.types.iter().flat_map(|t| &t.columns);
    let columns_grouped = group_by(columns, |c| c.name.to_lowercase());
    for (column_name, column_group) in columns_grouped {
        if MANDATORY_ITEMS_FIELDS.contains(&column_name.as_str()) {
            continue;
        }

        let needs_index = column_group.iter().any(|c| c.indexed);
        column_indexes.insert(column_name.to_string(), needs_index);

        if all_items_columns.contains(&column_name) {
            // SQLite cannot add columns "IF NOT EXIST", so we need to manually skip
            continue;
        }

        let db_type = column_group
            .first()
            .expect("All groups of `group_by` have at least 1 element");
        let db_type = db_type.dbtype;

        assert!(
            column_group.iter().all(|c| c.dbtype == db_type),
            "Column {} has inconsistent database type",
            column_name
        );
        declared_columns.insert(column_name, db_type);
    }
    (column_indexes, declared_columns)
}

// Solution taken from here:
// https://stackoverflow.com/questions/18920136/check-if-a-column-exists-in-sqlite
//
// Note that the approach of querying `pragma_table_info`
// does not work on older sqlcipher versions (ubuntu 20.04 still uses sqlcipher 3.4).
fn get_all_columns_gragma(
    table: &str,
    conn: &PooledConnection<SqliteConnectionManager>,
) -> rusqlite::Result<HashSet<String>> {
    let sql = format!("PRAGMA table_info('{}');", table);
    let mut stmt = conn.prepare_cached(&sql)?;
    let mut rows = stmt.query(NO_PARAMS)?;
    let mut result = HashSet::new();
    while let Some(row) = rows.next()? {
        let column_name: String = row
            .get(1)
            .expect("Column 1 of PRAGMA table_info code is not a table column name");
        result.insert(column_name);
    }
    Ok(result)
}

fn generate_sql(
    column_indexes: HashMap<String, bool>,
    declared_columns: HashMap<String, DatabaseColumnType>,
) -> String {
    let mut result = String::new();

    for (column, db_type) in declared_columns {
        let creation = format!(
            "ALTER TABLE items ADD {} {:?};",
            column,
            if db_type == DatabaseColumnType::Bool {
                DatabaseColumnType::Integer
            } else {
                db_type
            }
        );
        result.push_str(&creation);
        result.push_str("\n");
    }

    for (column, is_indexed) in column_indexes {
        let index = if is_indexed {
            format!(
                "CREATE INDEX IF NOT EXISTS idx_items_{} ON items({}) WHERE {} IS NOT NULL;",
                column, column, column
            )
        } else {
            format!("DROP INDEX IF EXISTS idx_items_{};", column)
        };
        result.push_str(&index);
        result.push_str("\n");
    }

    result
}

pub fn group_by<T, K, F>(collection: T, grouping_func: F) -> HashMap<K, Vec<T::Item>>
where
    T: IntoIterator,
    F: Fn(&T::Item) -> K,
    K: Eq + Hash,
{
    let mut map = HashMap::new();
    for item in collection {
        let group = grouping_func(&item);
        map.entry(group).or_insert_with(|| vec![]).push(item);
    }
    map
}

const MANDATORY_ITEMS_FIELDS: &[&str] = &[
    "uid",
    "type",
    "dateCreated",
    "dateModified",
    "dateAccessed",
    "deleted",
    "version",
];
